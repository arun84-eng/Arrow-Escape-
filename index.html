<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Arrows Escape</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0f172a">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            touch-action: none;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
        }
        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        .ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 5;
        }
        .ui-box {
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 8px 16px;
            color: white;
            font-weight: bold;
        }
        .ui-box span:last-child {
            font-size: 1.3rem;
        }
        .level-text { color: #fbbf24; }
        .score-text { color: #4ade80; }
        .lives-container { display: flex; align-items: center; gap: 5px; }
        .heart { font-size: 1.2rem; }
        
        .arrows-left {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 8px 20px;
            color: white;
            font-weight: bold;
            pointer-events: none;
            z-index: 5;
        }
        .arrows-left .count { color: #22d3ee; font-size: 1.3rem; }
        
        .screen-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        .screen-overlay.hidden { display: none; }
        .screen-title {
            font-size: 3rem;
            font-weight: bold;
            color: white;
            margin-bottom: 10px;
            text-align: center;
        }
        .screen-title.green { color: #4ade80; }
        .screen-title.red { color: #ef4444; }
        .screen-subtitle {
            color: #9ca3af;
            font-size: 1.1rem;
            margin-bottom: 5px;
        }
        .screen-score {
            color: #fbbf24;
            font-size: 3.5rem;
            font-weight: bold;
            margin-bottom: 20px;
        }
        .screen-info {
            color: #6b7280;
            margin-bottom: 30px;
        }
        .screen-info span { color: #22d3ee; }
        
        .btn {
            padding: 15px 50px;
            font-size: 1.2rem;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .btn:hover { transform: scale(1.05); }
        .btn:active { transform: scale(0.98); }
        .btn-green { background: linear-gradient(135deg, #22c55e, #16a34a); }
        .btn-blue { background: linear-gradient(135deg, #3b82f6, #4f46e5); }
        .btn-red { background: linear-gradient(135deg, #ef4444, #ec4899); }
        
        .instructions {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            padding: 8px 16px;
            color: #9ca3af;
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 5;
        }

        .total-levels {
            color: #9ca3af;
            font-size: 0.9rem;
            margin-top: 15px;
        }

        @media (max-width: 600px) {
            .screen-title { font-size: 2rem; }
            .screen-score { font-size: 2.5rem; }
            .btn { padding: 12px 40px; font-size: 1rem; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- UI Overlay -->
    <div class="ui-container">
        <div class="ui-box">
            <span>Level: </span>
            <span id="level" class="level-text">1</span>
            <span style="color:#6b7280;font-size:0.8rem"> / âˆž</span>
        </div>
        <div class="ui-box">
            <span>Score: </span>
            <span id="score" class="score-text">0</span>
        </div>
        <div class="ui-box lives-container">
            <span>Lives: </span>
            <div id="lives"></div>
        </div>
    </div>

    <!-- Arrows remaining display -->
    <div class="arrows-left">
        <span>Arrows: </span>
        <span id="arrowCount" class="count">5</span>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="screen-overlay">
        <div class="screen-title">ðŸŽ¯ Arrows Escape</div>
        <p class="screen-subtitle">Tap to shoot arrows into the rotating circle</p>
        <p class="screen-info">Don't hit the other arrows!</p>
        <button id="startBtn" class="btn btn-green">START GAME</button>
        <p class="total-levels">Unlimited levels with increasing difficulty!</p>
    </div>

    <!-- Level Complete Screen -->
    <div id="levelCompleteScreen" class="screen-overlay hidden">
        <div class="screen-title green">âœ… LEVEL COMPLETE!</div>
        <p class="screen-subtitle">Score</p>
        <p id="levelScore" class="screen-score">0</p>
        <button id="nextLevelBtn" class="btn btn-blue">NEXT LEVEL â†’</button>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="screen-overlay hidden">
        <div class="screen-title red">ðŸ’” GAME OVER</div>
        <p class="screen-subtitle">Final Score</p>
        <p id="finalScore" class="screen-score">0</p>
        <p class="screen-info">Level Reached: <span id="finalLevel">1</span></p>
        <button id="restartBtn" class="btn btn-red">PLAY AGAIN</button>
    </div>

    <!-- Instructions -->
    <div class="instructions">Tap or Press Space to shoot arrow</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Elements
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const levelCompleteScreen = document.getElementById('levelCompleteScreen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const nextLevelBtn = document.getElementById('nextLevelBtn');
        const scoreDisplay = document.getElementById('score');
        const levelDisplay = document.getElementById('level');
        const arrowCountDisplay = document.getElementById('arrowCount');
        const finalScoreDisplay = document.getElementById('finalScore');
        const finalLevelDisplay = document.getElementById('finalLevel');
        const levelScoreDisplay = document.getElementById('levelScore');
        const livesDisplay = document.getElementById('lives');

        // Game State
        let gameRunning = false;
        let score = 0;
        let level = 1;
        let lives = 3;
        let centerX, centerY;
        let circleRadius = 70;
        let rotationAngle = 0;
        let rotationSpeed = 0.02;
        let stuckArrows = [];
        let playerArrow = null;
        let arrowsToShoot = 5;
        let particles = [];
        let canShoot = true;

        // Helper function to draw rounded rectangles (for older browser support)
        function drawRoundRect(x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        // Resize canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            centerX = canvas.width / 2;
            centerY = canvas.height / 2 - 50;
            
            // Adjust circle radius based on screen size
            circleRadius = Math.min(70, Math.min(canvas.width, canvas.height) * 0.12);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Arrow that's stuck in the circle
        class StuckArrow {
            constructor(angle) {
                this.angle = angle;
                this.length = 50;
                this.width = 6;
            }

            getPosition() {
                const globalAngle = this.angle + rotationAngle;
                return {
                    x: centerX + Math.cos(globalAngle) * circleRadius,
                    y: centerY + Math.sin(globalAngle) * circleRadius,
                    angle: globalAngle
                };
            }

            draw() {
                const pos = this.getPosition();
                
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(pos.angle + Math.PI / 2);

                // Arrow shaft
                const gradient = ctx.createLinearGradient(0, 0, 0, this.length);
                gradient.addColorStop(0, '#64748b');
                gradient.addColorStop(1, '#94a3b8');
                
                ctx.fillStyle = gradient;
                drawRoundRect(-this.width/2, 0, this.width, this.length, 2);

                // Arrow head (pointing outward - into circle)
                ctx.fillStyle = '#e2e8f0';
                ctx.beginPath();
                ctx.moveTo(0, -12);
                ctx.lineTo(-10, 8);
                ctx.lineTo(10, 8);
                ctx.closePath();
                ctx.fill();

                // Fletching (at end sticking out)
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.moveTo(-this.width/2, this.length);
                ctx.lineTo(-12, this.length + 12);
                ctx.lineTo(-this.width/2, this.length - 8);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(this.width/2, this.length);
                ctx.lineTo(12, this.length + 12);
                ctx.lineTo(this.width/2, this.length - 8);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }
        }

        // Player's arrow to shoot
        class PlayerArrow {
            constructor() {
                this.x = centerX;
                this.y = canvas.height - 100;
                this.length = 50;
                this.width = 6;
                this.speed = 0;
                this.maxSpeed = 18;
                this.isMoving = false;
                this.pulsePhase = 0;
            }

            shoot() {
                if (!this.isMoving && canShoot) {
                    this.isMoving = true;
                    this.speed = this.maxSpeed;
                    canShoot = false;
                }
            }

            update() {
                this.pulsePhase += 0.1;
                
                if (this.isMoving) {
                    this.y -= this.speed;

                    // Check if reached the circle
                    const distToCenter = Math.sqrt(
                        Math.pow(this.x - centerX, 2) + 
                        Math.pow(this.y - centerY, 2)
                    );

                    if (distToCenter <= circleRadius + 12) {
                        this.isMoving = false;
                        
                        // Calculate angle where arrow hit
                        const hitAngle = Math.atan2(this.y - centerY, this.x - centerX) - rotationAngle;
                        
                        // Check collision with existing arrows
                        let collision = false;
                        for (let arrow of stuckArrows) {
                            let angleDiff = hitAngle - arrow.angle;
                            // Normalize angle difference to -PI to PI
                            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                            angleDiff = Math.abs(angleDiff);
                            
                            // Collision threshold based on level difficulty
                            const threshold = Math.max(0.18, 0.28 - level * 0.01);
                            if (angleDiff < threshold) {
                                collision = true;
                                break;
                            }
                        }

                        if (collision) {
                            // Hit another arrow!
                            createExplosion(this.x, this.y);
                            lives--;
                            updateLivesDisplay();
                            
                            if (lives <= 0) {
                                setTimeout(() => endGame(), 300);
                            } else {
                                // Reset arrow for retry
                                setTimeout(() => {
                                    playerArrow = new PlayerArrow();
                                    canShoot = true;
                                }, 600);
                            }
                        } else {
                            // Successfully stuck!
                            stuckArrows.push(new StuckArrow(hitAngle));
                            arrowsToShoot--;
                            score += 10 * level;
                            scoreDisplay.textContent = score;
                            arrowCountDisplay.textContent = arrowsToShoot;
                            
                            createSuccessParticles(this.x, this.y);

                            if (arrowsToShoot <= 0) {
                                // Level complete!
                                setTimeout(() => levelComplete(), 600);
                            } else {
                                // Spawn new arrow
                                setTimeout(() => {
                                    playerArrow = new PlayerArrow();
                                    canShoot = true;
                                }, 350);
                            }
                        }
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Glow effect when ready
                if (!this.isMoving && canShoot) {
                    const pulseSize = 3 + Math.sin(this.pulsePhase) * 2;
                    ctx.shadowColor = '#4ade80';
                    ctx.shadowBlur = 15 + pulseSize;
                }

                // Arrow shaft
                const gradient = ctx.createLinearGradient(0, -this.length/2, 0, this.length/2);
                gradient.addColorStop(0, '#22c55e');
                gradient.addColorStop(1, '#4ade80');
                
                ctx.fillStyle = gradient;
                drawRoundRect(-this.width/2, -this.length/2, this.width, this.length, 2);

                // Arrow head
                ctx.fillStyle = '#86efac';
                ctx.beginPath();
                ctx.moveTo(0, -this.length/2 - 18);
                ctx.lineTo(-10, -this.length/2 + 5);
                ctx.lineTo(10, -this.length/2 + 5);
                ctx.closePath();
                ctx.fill();

                // Fletching
                ctx.fillStyle = '#15803d';
                ctx.beginPath();
                ctx.moveTo(-this.width/2, this.length/2);
                ctx.lineTo(-12, this.length/2 + 15);
                ctx.lineTo(-this.width/2, this.length/2 - 8);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(this.width/2, this.length/2);
                ctx.lineTo(12, this.length/2 + 15);
                ctx.lineTo(this.width/2, this.length/2 - 8);
                ctx.closePath();
                ctx.fill();

                ctx.restore();
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, color, isSuccess = false) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 5 + 2;
                this.speedX = (Math.random() - 0.5) * (isSuccess ? 6 : 10);
                this.speedY = (Math.random() - 0.5) * (isSuccess ? 6 : 10);
                this.color = color;
                this.life = 1;
                this.decay = Math.random() * 0.025 + 0.015;
                this.gravity = isSuccess ? 0.08 : 0.15;
            }

            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += this.gravity;
                this.speedX *= 0.98;
                this.life -= this.decay;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function createExplosion(x, y) {
            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(x, y, '#ef4444'));
                particles.push(new Particle(x, y, '#f97316'));
                particles.push(new Particle(x, y, '#fbbf24'));
            }
        }

        function createSuccessParticles(x, y) {
            for (let i = 0; i < 12; i++) {
                particles.push(new Particle(x, y, '#4ade80', true));
                particles.push(new Particle(x, y, '#22d3ee', true));
            }
        }

        // Update lives display
        function updateLivesDisplay() {
            livesDisplay.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                const heart = document.createElement('span');
                heart.textContent = i < lives ? 'â¤ï¸' : 'ðŸ–¤';
                heart.className = 'heart';
                livesDisplay.appendChild(heart);
            }
        }

        // Draw the rotating circle (target)
        function drawCircle() {
            ctx.save();
            
            // Outer glow
            ctx.shadowColor = '#3b82f6';
            ctx.shadowBlur = 25;
            
            // Main circle
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, circleRadius);
            gradient.addColorStop(0, '#1e3a5f');
            gradient.addColorStop(0.6, '#1e40af');
            gradient.addColorStop(1, '#3b82f6');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
            ctx.fill();

            // Inner circle
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#0f172a';
            ctx.beginPath();
            ctx.arc(centerX, centerY, circleRadius * 0.55, 0, Math.PI * 2);
            ctx.fill();

            // Center dot
            ctx.fillStyle = '#60a5fa';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
            ctx.fill();

            // Rotating indicator line
            ctx.strokeStyle = 'rgba(96, 165, 250, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + Math.cos(rotationAngle) * circleRadius * 0.5,
                centerY + Math.sin(rotationAngle) * circleRadius * 0.5
            );
            ctx.stroke();

            ctx.restore();
        }

        // Initialize level
        function initLevel() {
            stuckArrows = [];
            particles = [];
            
            // Add initial arrows based on level (more arrows = harder)
            const initialArrows = Math.min(2 + Math.floor(level / 2), 8);
            for (let i = 0; i < initialArrows; i++) {
                // Spread them out evenly with small random offset
                const angle = (i / initialArrows) * Math.PI * 2 + (Math.random() - 0.5) * 0.4;
                stuckArrows.push(new StuckArrow(angle));
            }
            
            // Set arrows to shoot (increases with level)
            arrowsToShoot = Math.min(4 + level, 12);
            arrowCountDisplay.textContent = arrowsToShoot;
            
            // Increase rotation speed with level
            rotationSpeed = 0.018 + (level * 0.004);
            
            // Cap max speed
            rotationSpeed = Math.min(rotationSpeed, 0.08);
            
            // Random direction change after level 2
            if (level > 2 && Math.random() > 0.6) {
                rotationSpeed *= -1;
            }
            
            // Variable speed after level 5
            if (level > 5 && Math.random() > 0.7) {
                // Will add oscillating speed
            }
            
            playerArrow = new PlayerArrow();
            canShoot = true;
            
            levelDisplay.textContent = level;
        }

        // Initialize game
        function initGame() {
            score = 0;
            level = 1;
            lives = 3;
            rotationAngle = 0;
            scoreDisplay.textContent = '0';
            updateLivesDisplay();
            initLevel();
        }

        // Level complete
        function levelComplete() {
            gameRunning = false;
            levelCompleteScreen.classList.remove('hidden');
            levelScoreDisplay.textContent = score;
        }

        // Next level
        function nextLevel() {
            level++;
            levelCompleteScreen.classList.add('hidden');
            initLevel();
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        }

        // Game loop
        function gameLoop() {
            if (!gameRunning) return;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw subtle background grid
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.05)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Update rotation (with slight oscillation for higher levels)
            let currentSpeed = rotationSpeed;
            if (level > 5) {
                currentSpeed = rotationSpeed * (1 + 0.3 * Math.sin(Date.now() * 0.002));
            }
            rotationAngle += currentSpeed;

            // Draw circle
            drawCircle();

            // Update and draw particles
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            // Draw stuck arrows
            stuckArrows.forEach(arrow => arrow.draw());

            // Update and draw player arrow
            if (playerArrow) {
                playerArrow.update();
                playerArrow.draw();
            }

            // Draw waiting arrows indicator at bottom
            const waitingY = canvas.height - 35;
            const arrowsToShow = Math.min(arrowsToShoot - 1, 10);
            const startX = centerX - (arrowsToShow * 11);
            for (let i = 0; i < arrowsToShow; i++) {
                ctx.fillStyle = '#4ade80';
                ctx.globalAlpha = 0.5;
                drawRoundRect(startX + i * 22, waitingY, 5, 20, 2);
                ctx.globalAlpha = 1;
            }

            // Draw trajectory line (guide)
            if (playerArrow && !playerArrow.isMoving && canShoot) {
                ctx.strokeStyle = 'rgba(74, 222, 128, 0.2)';
                ctx.setLineDash([5, 10]);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(playerArrow.x, playerArrow.y - playerArrow.length/2);
                ctx.lineTo(centerX, centerY + circleRadius);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            requestAnimationFrame(gameLoop);
        }

        // Start game
        function startGame() {
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            levelCompleteScreen.classList.add('hidden');
            initGame();
            gameRunning = true;
            requestAnimationFrame(gameLoop);
        }

        // End game
        function endGame() {
            gameRunning = false;
            gameOverScreen.classList.remove('hidden');
            finalScoreDisplay.textContent = score;
            finalLevelDisplay.textContent = level;
        }

        // Event listeners
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);
        nextLevelBtn.addEventListener('click', nextLevel);

        // Click/tap to shoot
        function handleShoot(e) {
            if (e.target.tagName === 'BUTTON') return;
            
            if (gameRunning && playerArrow && canShoot) {
                playerArrow.shoot();
            }
        }

        // Mouse click
        document.addEventListener('click', handleShoot);
        
        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameRunning && playerArrow && canShoot) {
                    playerArrow.shoot();
                }
            }
        });

        // Touch
        document.addEventListener('touchstart', (e) => {
            if (e.target.tagName === 'BUTTON') return;
            e.preventDefault();
            if (gameRunning && playerArrow && canShoot) {
                playerArrow.shoot();
            }
        }, { passive: false });

        // Initialize
        updateLivesDisplay();
    </script>
    <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("sw.js");
    }
</script>

</body>
</html>
